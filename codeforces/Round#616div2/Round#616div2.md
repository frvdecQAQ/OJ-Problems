# Round#616(div2)

#### Even But not Even:

签到题，根据数字串里能不能找到两个奇数分情况讨论构造即可

#### Array Sharpening：

某个位置的数根据k在这个位置左边或者k在这个位置右边有两种不同的最小值，枚举每一个位置，然后根据这个位置上的数和这两个最小值分类讨论，逐步缩小k的可行范围即可。

#### Mind Control：

mth的位置可能会面临m种不同的双端选择，每种选择显然要取两端最大值，然后根据选择的数值从小到大排序，同时记录这种选择前面被选了多少数字。

由于数据范围很小，接下来只有枚举控制多少人选择前面，然后再枚举m种不同的双端选择判断即可，时间复杂度O(mk)

#### Irreducible Anagrams：

考虑如何判断一个字符串是不是if the corresponding substring has at least one irreducible anagram的，不妨设这个字符串是s[1……n]

- $s[1]\neq s[n]$

  ​	构造字符串s[n]+s[2……n-1]+s[1], 显然这是跟原字符串irreducible anagram的

- $s[1] == s[n] \&\& s[1……n]$有至少三种不同的字符

  ​	不妨设$s[1]=s[n]=a$，任取其余两种字符设为$b,c$，且保证最后一个$c$字符出现的位置比最后一个$b$字符出现的位置靠后（如果不满足条件，交换$b,c$即可)，设a，b，c的数量分别为A，B，C个，那么构造字符串c\*C+a\*A+b*B，考虑构造串的前缀和字符串对应前缀c的数量相等的位置和构造串的后缀和字符串对应后缀b的数量相等的位置即可证明构造串和原字符串irreducible anagram

- $s[1]==s[n]\&\&s[1……n]$最多有两种不同的字符

  ​	首先考虑n=1的情况，显然原串和原串是irreducible anagram的

  ​	当n>1的时候，不妨设s[1]=s[n]=a，另一种字符为b，如果没有另一种字符，显然不存在串和原串是irreducible anagram的。满足条件的构造串p一定有p[1]=p[n]=b，考虑构造串的前缀和原串的对应前缀种b的数量，一开始的时候构造串前缀中b的数量大于原串对应前缀中b的数量，而显然构造串p[1……n-1]中b的数量要小于s[1……n-1]中的b的数量，那么易证一定存在一个构造串的前缀和原串的对应前缀中b的数量相同，又因为最多有两种字符，所以a的数量也相同，构造串一定和原串不是irreducible anagram，那么显然就不存在串和原串是irreducible anagram的

在有了以上结论之后，只需要处理每个位置向左最多能扩展到的位置（保证最多有两种不同的字符)，位置满足单调性，线性扫一遍就能求出来，然后根据以上结论判断即可

#### Prefix Enlightenment：

题目条件：任意三个控制开关的控制集合无交集，翻译过来是任何一个位置最多被两个控制开关控制。

显然一个开关要么被打开0次，要么被打开1次（打开1次以上显然不是最优方案），而对于一个位置，如果只被一个控制开关控制，那么可以确定这个控制开关的打开次数；如果被两个控制开关控制，可以确定这两个控制开关的打开次数异或后的值。

很容易构造一个图，其中任意一条边上的两个点不能都是黑色或者都是白色，和上述条件一一对应。对于其中的某个联通块，如果某个点的颜色确定了，那么其他点的颜色也就都确定了，因此最多有两种不同的染色方案。因此需要对联通性及联通块的信息做维护，使用并查集即可。

#### Coffe Varieties：

关键在于，要想明白虽然很难用长度为k的序列去检测另一个长度为k的序列中的各个数字是否出现重复，但是是很容易用长度为k/2的序列去检测另一个长度为k/2的序列的，因为检测过程中新加入的数字并不会挤掉原来的长度为k/2的序列的数字(k = 1的时候需要特判一下)

把长度为n的序列分成若干个长度为k/2的块，可以用n次询问就可以判定每个块内重复的数字，考虑块和块之间的重复，采用上面的方法可以花费k次询问判定两个k/2的块之间的重复，如果直接用这种朴素算法，需要的询问次数为
$$
\begin{align}
 & n+\frac{\frac{2n}{k}(\frac{2n}{k}-1)}{2}*k\\
 = & n+\frac{2n^2}{k}-n\\
 = & \frac{2n^2}{k}\\
\end{align}
$$
这实际上就是Easy Version中要求的上限

考虑对算法做优化，会发现每次检测的要把一个k/2的块push进去，再把另一个k/2的块push进去，而一次检测的后半部分可以当作另一次检测的前半部分，这样的话就可以用k/2次询问完成后面的每次判定。我的实现中通过有序检测，即每个块只能用来检测后面的块来保证不会出现类似交叉检测的问题，然后贪心，每次能继续检测就继续检测，否则就停止，当检测次数达到$\frac{2n}{k}(\frac{2n}{k}-1)$的时候就停止检测。可以证明，需要的询问次数为（第一次长度为n的扫描已经对相邻的块进行了检测，因此在后面的有序检测中不要再检测相邻的）
$$
\begin{align}
& \frac{\frac{2n}{k}\frac{n}{k}}{2}*\frac{k}{2}+\frac{\frac{2n}{k}(\frac{2n}{k}-1)}{2}*\frac{k}{2}\\
= &\frac{n^2}{2k}+\frac{n}{2k}(\frac{2n}{k}-1)\\
= & \frac{3n^2}{2k}-\frac{n}{2k} < \frac{3n^2}{2k}
\end{align}
$$
满足Hard Version的条件