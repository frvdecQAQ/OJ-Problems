# Round#617 div3 题解

#### Array with Odd Sum:

​	分成只有偶数，只有奇数，奇数偶数都有三种情况讨论一下即可

#### Food Buying：

​	显然当money >=10的时候，每次使用恰好是10的倍数的钱是最优的，贪心+模拟即可

#### Yet Another Walking Robot：

​	令LR[i]表示前i个字符中L字符减去R字符的值，UD[i]表示前i个字符中U字符减去D字符的值，如果要删去[l, r]的子串同时满足条件, 可以得到
$$
LR[l-1]+(LR[n]-LR[r])=LR[n]\\
UD[l-1]+(UD[n]-UD[r])=UD[n]
$$
​	即要求LR[l-1] = LR[r], UD[l-1] = UD[r]，枚举r，用map在枚举过程中维护一下就可以找到每个r对应的最大的l，然后根据题目要求找到**最短的非空子串**即可

#### Fight With Monsters：

​	设h[i]表示第i个怪物的血量，如果h[i]%(a+b) == 0，令tmp[i] = a+b, 否则令tmp[i] = h[i]%(a+b)

​	如果tmp[i] <= a，显然不需要跳过回合就可以获得分数

​	否则至少需要(tmp[i]-a)/a (向上取整)次跳过才可以获得分数

​	将这些需要跳过才能获得分数的怪物按照至少需要跳过的回合数从小到大排序，然后贪心即可

#### String Coloring:

​	很容易证明染成同一种颜色的数字的相对顺序不能发生变化，染成不同颜色的数字的相对顺序是可以调换的。换言之，判断染色方案的合法性的充要条件是染成同一种颜色的数字一定是单调不降子序列。

​	用**数学归纳法**很容易证明以下算法的正确性：

​			对于长度为n的序列，假设它最少可以分成k个单调不降子序列，且在满足k最小的情况下，这k个单调子序列的末尾的最小值最小，且在满足以上条件的情况下，这k个单调子序列的末尾的次小值最小……

​			那么在该序列后面加入一个数字使其变成长度为n+1的序列，对于加入的数字X，如果X比k个序列的末尾的最小值还要小，那么就单独以X开一个序列，变成k+1个序列，否则就找到k个序列的末尾值中满足末尾值<=X的最大的末尾值，在它后面加入数字X。

​			这样变换后的长度为n+1的序列满足之前长度为n的序列满足的条件

​	模拟这个算法的实现用数据结构维护一下即可

#### Berland Beauty：

​	根据乘客的描述，可以确定每条边的可能的最小值，可以证明，如果每条边都取其可能的最小值作为这条边的值，该方案仍然不是一个合法的方案，那么就不存在合法的方案。问题转化为确定每条边的可能的最小值，由于本题数据范围较小，随便暴力搞搞即可。

​	如果数据范围扩大，将乘客的描述按照最小值排序，然后树链剖分+线段树做区间覆盖即可

​	